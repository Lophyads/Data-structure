
namespace Seg{ //洛谷P2617 Dynamic Rankings 先离散化再搞会更快
	#define lc(x) tr[x].ls
	#define rc(x) tr[x].rs
	struct node{
		int ls, rs, v;
	};
	constexpr static int N = (500e6) / sizeof(struct node);
	constexpr static int L = 1, R = 1e9 + 7;
	struct node tr[N];
	int update(int pos, int v, int nw, int l = L, int r = R){
		if(!nw) nw = ++ cnt;	
		assert(cnt < N);
		tr[nw].v += v;
		if(l == r) return nw;
		int mid = (l + r) >> 1;
		if(pos <= mid) lc(nw) = update(pos, v, lc(nw), l, mid);
		else rc(nw) = update(pos, v, rc(nw), mid + 1, r);
		return nw; 
	}
	int query(int l, int r, int k){
		int t1 = 0, t2 = 0;
		for(int i = l - 1; i; i &= (i - 1)) b1[t1++] = rt[i];
		for(int i = r; i; i &= (i - 1)) b2[t2++] = rt[i];
		int ll = 1, rr = R;
		while(ll < rr){
			int sl = 0;
			int mid = (ll + rr) >> 1;
			_rep(i, 0, t1) sl -= tr[lc(b1[i])].v;
			_rep(i, 0, t2) sl += tr[lc(b2[i])].v;
			if(sl >= k){
				rr = mid;
				for(int i = 0; i < t1; i ++) b1[i] = lc(b1[i]);
				for(int i = 0; i < t2; i ++) b2[i] = lc(b2[i]);
			}
			else{
				ll = mid + 1;
				k -= sl;
				for(int i = 0; i < t1; i ++) b1[i] = rc(b1[i]);
				for(int i = 0; i < t2; i ++) b2[i] = rc(b2[i]);
			}
		}
		return ll;
	}
	void change(int pos, int x, int v){
		while(pos <= n) {
			update(x, v, rt[pos]);
			pos += (pos & (-pos));
		}
	}
};
using namespace Seg;
int main(){
	ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	_rep(i, 1, n + 1) rt[i] = ++ cnt;
	_rep(i, 1, n + 1) {
		cin >> a[i];
		change(i, a[i], 1);
	}
	_rep(i, 0, m){
		char op;
		cin >> op;
		if(op == 'Q'){
			int l, r, k;
			cin >> l >> r >> k;
			cout << query(l, r, k) << "\n";
		}
		else{
			int pos, v;
			cin >> pos >> v;
			change(pos, a[pos], -1);
			a[pos] = v;
			change(pos, a[pos], 1);
		}
	}
	return 0;
} 